---
title: 
author: 
date:
output: 
  revealjs::revealjs_presentation:
    css: metropolis.css
    self_contained: false
    transition: none
    background_transition: none
    reveal_options:
      slideNumber: true
      previewLinks: true
      minScale: 1.0
      maxScale: 1.0
      fig_caption: true
      width: 1000
      height: 600
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Presentation Bronze Age Round Table 

<font size="6">**A computational Cultural Transmission model of burial rites in Central, Northern and North-western Europe**</font>

Clemens Schmid -- 05. Juni 2018

<figure>
  <img src="figures/devils_jump.jpg">
  <figcaption>© Michael Codd -- Devil's Jumps, Treyford, West Sussex, Barrow Cemetery -- West Sussex County Council, www.artuk.org [03.06.18]</figcaption>
</figure>

## Presentation Bronze Age Round Table 

<font size="6">**A computational Cultural Transmission model of burial rites in Central, Northern and North-western Europe**</font>

Clemens Schmid -- 05. Juni 2018

- **Context: Burial rites in Central Europe**
- **Data**
  - Overview
  - The case of Southwestern Germany (Falkenstein)
- **Theory**
  - Cultural Evolution
  - Transmission of neutral variants (Dunnel + Neiman)
- **Model & Simulation**
  - Population generation
  - Simulation implementation
  - First simultation runs

⚠ work in progress ⚠

## RADON-B date distribution

<figure>
  <img src="figures/general_map.jpeg">
  <figcaption>All ^14^C-dates from graves 2200-800calBC</figcaption>
</figure>

## Research area 

<figure>
  <img src="figures/general_map_research_area_unzoomed.jpeg">
  <figcaption>Artifical research area (rectangular form in Europe Albers Equal Area Conic EPSG: 102013) </figcaption>
</figure>

## 

<section data-background-video="figures/the_movie_4.mp4" data-background-color="#f1f1f1">
</section>

## Diachronic perspective

<figure>
  <img src="figures/general_map_research_area_timeslices.jpeg">
  <figcaption>Timeslices of 200 years in between 2200-800calBC</figcaption>
</figure>

## Artificial comparison regions based on a regular grid 

<figure>
  <img src="figures/general_map_research_area_regions.jpeg">
  <figcaption>Grid point distance: 400km, Circle radius: 240km, only regions with >=70 graves were kept</figcaption>
</figure>

## Spatio-temporal development (amount of graves)

<div id="left">
  <figure>
    <img src="figures/development_amount_regions_burial_type.jpeg">
  </figure>
</div>
<div id="right">
  <figure>
    <img src="figures/development_amount_regions_burial_construction.jpeg">
  </figure>
</div>

## Spatio-temporal development (proportion of ideas)

<div id="left">
  <figure>
    <img src="figures/development_proportions_regions_burial_type.jpeg">
  </figure>
</div>
<div id="right">
  <figure>
    <img src="figures/development_proportions_regions_burial_construction.jpeg">
  </figure>
</div>

## Closer look: Southwestern Germany

Falkenstein

## Temporal Dynamics of Drift (and Innovation)

```{r}
#system("xfce4-terminal -e \"bash -c \\\"R -e 'getwd(); shiny::runApp(deparse(substitute(shiny_neiman_1.R)), port = 3539)'; bash\\\"\" -T \"Run and ready\"")
```

<iframe src="http://127.0.0.1:3539" style="width: 8000px; height: 700px"></iframe>

## Homogeneity Under Drift (and Innovation)

```{r}
#system("xfce4-terminal -e \"bash -c \\\"R -e 'getwd(); shiny::runApp(deparse(substitute(shiny_neiman_2.R)), port = 3540)'; bash\\\"\" -T \"Run and ready\"")
```

<iframe src="http://127.0.0.1:3540" style="width: 8000px; height: 700px"></iframe>

## Dynamics of Stylistic Distance between Two Groups

```{r}
#system("xfce4-terminal -e \"bash -c \\\"R -e 'getwd(); shiny::runApp(deparse(substitute(shiny_neiman_3.R)), port = 3541)'; bash\\\"\" -T \"Run and ready\"")
```

<iframe src="http://127.0.0.1:3541" style="width: 8000px; height: 700px"></iframe>

## Model settings

```{r eval = FALSE, echo = TRUE}

# create models_grid data.frame
models_grid <- expand.grid(
  # general settings
  timeframe = list(
    0:1400
  ),
  # population settings  
  population_size_functions = c(
    function(t) {40}
    # function(t) {round(0.0002 * (t - 700)^2 + 10, 0)}
  ),
  units_amount = c(
    8
  ),
  age_distribution_functions = c(
    function(x) {1 / (1 + 0.0004 * 0.7^(-7*log(x)))}
  ),
  age_ranges = list(
    1:100
  ),
  # relations settings
  amounts_friends = list(
    20
  ),
  unit_interaction_matrix = list(
    t(matrix(
      c(
        0,1,1,1,1,1,1,1,
        1,0,1,1,1,1,1,1,
        1,1,0,1,1,1,1,1,
        1,1,1,0,1,1,1,1,
        1,1,1,1,0,1,1,1,
        1,1,1,1,1,0,1,1,
        1,1,1,1,1,1,0,1,
        1,1,1,1,1,1,1,0
      ),
      8, 8
    ))
  ),
  cross_unit_proportion_child_of = list(
    0
  ),
  cross_unit_proportion_friend = list(
    0,
    0.01,
    0.10
  ),
  weight_child_of = list(
    5
  ),
  weight_friend = list(
    3
  ),
  # ideas settings
  names = list(
    c("idea_1", "idea_2")
  ),
  start_distribution = list(
    start_proportion_burial_type
  ), 
  strength = list(
    c(1, 1) 
  )
) %>% tibble::as.tibble() %>%
  dplyr::mutate(
    multiplier = 1:nrow(.)
  ) %>%
  tidyr::uncount(1) %>%
  dplyr::mutate(
    model_id = 1:nrow(.)
  )

```

## Population graphs

<figure>
  <img src="figures/population_graph_connection_0.jpeg">
  <figcaption>Constant population size of 40, 1400 years, Cross unit horizontal contact proportion: 0</figcaption>
</figure>


## Population graphs

<figure>
  <img src="figures/population_graph_connection_001.jpeg">
  <figcaption>Constant population size of 40, 1400 years, Cross unit horizontal contact proportion: 0.01</figcaption>
</figure>


## Population graphs

<figure>
  <img src="figures/population_graph_connection_01.jpeg">
  <figcaption>Constant population size of 40, 1400 years, Cross unit horizontal contact proportion: 0.1</figcaption>
</figure>

## Expansion

```{cpp eval = FALSE, echo = TRUE}
void Idea::expand() {
  
  // get all neighboring nodes
  std::vector<int> all_neighbors = this->get_all_neighboring_nodes();
  // remove duplicates from neighbors
  std::vector<int> neighbors_without_doubles = remove_duplicates(all_neighbors);
  // remove the current nodes from neighbors
  std::vector<int> neighbors = erase_elements_of_second_vector_from_the_first(
    neighbors_without_doubles, this->current_nodes
  );
  
  // make decision: which neighbors can be converted
  std::vector<int> converted = this->select_nodes_to_convert(neighbors);
  
  // delete current nodes from graph
  for (auto& i : this->current_nodes) {
    if(this->realworld->does_node_exist(i)) {
      this->realworld->delete_nodes(i);
      this->dead_nodes.push_back(i);
    }
  }
  
  // forget current nodes and make neighbors new current nodes
  this->current_nodes.clear();
  this->current_nodes.insert(
    this->current_nodes.end(), converted.begin(), converted.end()
  );
  
}
```

